class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        // use unordered_map<char, unordered_set<string>> to remember the location of each chars
        // use unordered_set<string> to record to visited position
        // back tracking method
        // stop once we found a solution
        // if no solution can be found at the end of the iteration, return false
        unordered_map<char, unordered_set<string>> m;
        int bm = board.size(), bn = board[0]. size();
        for(int i = 0; i < bm; i++){
            for(int j = 0; j < bn; j++){
                m[board[i][j]].insert(to_string(i) + " " + to_string(j));
            }
        }
        if(m.find(word[0]) == m.end()) return false;
        unordered_set<string> visited;
        for(auto pos:m[word[0]]){
            visited.insert(pos);
            if(helper(m, visited, word, 1, pos, bm, bn)) return true;
            visited.erase(pos);
        }
        return false;
    }
    
    bool helper(unordered_map<char, unordered_set<string>> &m, unordered_set<string> &visited, string &w, int start, string pos, int bm, int bn){
        //cout << pos << endl;
        // reach the end of w, return true
        if(start == w.size()) return true;
        if(m.find(w[start]) == m.end()) return false;
        unordered_set<string> temp = m[w[start]];
        // next position on board
        vector<string> nxt_pos = nxtPos(pos, bm, bn);
        for(int i = 0; i < nxt_pos.size(); i++){
            // if this position has been visited or this position does not contains the char we want, continue
            if(temp.find(nxt_pos[i]) == temp.end() || visited.find(nxt_pos[i]) != visited.end()) continue;
            // insert the new pos
            visited.insert(nxt_pos[i]);
            if(helper(m, visited, w, start + 1, nxt_pos[i], bm, bn)) return true;
            visited.erase(nxt_pos[i]);
        }
        return false;
    }
    
    vector<string> nxtPos(string pos, int m, int n){
        stringstream s(pos);
        vector<string> res;
        string temp;
        getline(s, temp, ' ');
        int x = stoi(temp);
        getline(s, temp);
        int y = stoi(temp);
        if(x+1 < m) res.push_back(to_string(x+1) + " " + to_string(y));
        if(x-1 >= 0) res.push_back(to_string(x-1) + " " + to_string(y));
        if(y+1 < n) res.push_back(to_string(x) + " " + to_string(y+1));
        if(y-1 >= 0) res.push_back(to_string(x) + " " + to_string(y-1));
        return res;
    }
};
